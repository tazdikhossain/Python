"""Generic Algorithm (Binary).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qIqwvkASagbAjfGZf1W3WMomy5D493jC
"""

import numpy as np
np.random.seed(2)

#initialization of Constants
population_size = 6
chromosome_size = 4
crossover_probability = 0.7
mutation_probability = 0.01
parent_selection = 0.10

#Fitness Function 
def fitness_func(x):
    return 15*x - x**2

#Generating initial Chromosomes of a population
def initial_population(population_size,chromosome_size):
    chromosomes = []
    for i in range(population_size):
        chromosomes.append([np.random.randint(0,2) for _ in range(chromosome_size)])
    return chromosomes

# Decimal Converions
def decode(x):
    sum = 0
    counter = len(x)-1
    for i in range(len(x)):
        sum += x[i]* pow(2,counter)
        counter-=1
    return sum

#Generating all possible Pairs of selected parent Chromosomes
def pair(selected_parent):
        result = []
        for p1 in range(len(selected_parent)):
                for p2 in range(p1+1,len(selected_parent)):
                        result.append([selected_parent[p1],selected_parent[p2]])
        return result


#CrossOver Between 2 Chromosomes
def single_point_crossover(a,b,crossover_probability):
    if len(a) != len(b):
        raise ValueError('Chromosomes a and b must be same length')
    if np.random.choice([True,False],p=[crossover_probability,1-crossover_probability]):
        p = np.random.randint(1,len(a))
        return a[0:p]+b[p:] , b[0:p]+a[p:]
    else:
      return a,b

#Mutation of a Chromosome
def mutation(x, mutation_probability):
    for i in range(len(x)):
        if np.random.choice([True,False],p=[mutation_probability,1-mutation_probability]):
            x[i] = abs(x[i]-1)
    return x
chromosomes = initial_population(population_size,chromosome_size)                                     #initialize chromosomes of the size equal to population_size

print(chromosomes)

for genaration in range(100):                                                                         #Generations of Chromosomes
    fitness_values = []
    fitness_ratio = []
    # print(len(chromosomes))
    for i in range(len(chromosomes)):
        decimal = decode(chromosomes[i])                                                              #for each chromosome values are converting to decimal and
        fitness_values.append(fitness_func(decimal))                                                  #Calculate fitness Function
    
    for i in range(len(fitness_values)):
        fitness_ratio.append(fitness_values[i]/sum(fitness_values))                                   #Calculate fitness Ratio of each chromosomes

    selected_parent = []
    # for i in range(len(fitness_ratio)):                                                               #Parent Selection
    #     if fitness_ratio[i]>parent_selection:                                                         #Thershold of Fitness
    #         selected_parent.append(i)                                                                 #saving the indexes of selected chromosomes


    selected_parent = sorted(range(len(fitness_ratio)), key=lambda i: fitness_ratio[i], reverse=True)[:4] #select Top 4 fitness Ratio Chromosome

    
    pairs = pair(selected_parent)                                                                     #Genarating all possible pairs of selected chromosomes
    # print(pairs)
    rindex = [np.random.randint(0,len(pairs)) for _ in range(population_size//2)]                     #Randomly selecting (population_size//2) pairs to reproduction [As each mating produce 2 chromosomes]
    # print(rindex)
    new_offset = []
    for i in range(len(rindex)):
        a,b = single_point_crossover(chromosomes[pairs[rindex[i]][0]],chromosomes[pairs[rindex[i]][1]], crossover_probability)  #Crossover of chromosome pairs
        new_offset.append(a)
        new_offset.append(b)                                                                          #new offset Chromosomes


    for i in range(len(new_offset)):
        new_offset[i] = mutation(new_offset[i],mutation_probability)                                  #Mutation of chromosomes

    chromosomes = new_offset                                                                          #new offset become the new Chromosomes

    print(f"Genaration: {genaration} -> Fitness: {sum(fitness_values)} -> Average: {sum(fitness_values)/population_size}")                                                                             #clearing the pre



print(chromosomes)